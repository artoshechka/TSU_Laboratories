global _start
section .bss
strA resb 255
section .data
isOk db 1
msgNot db "String is Wrong", 0xA,0x0
msgNotP db "String is Not P", 0xA,0x0
msgOk db "String is Good", 0xA,0x0
val db 0
section .text
_start:
mov eax,3
mov ebx,0
mov ecx,strA
mov edx,255
int 0x80
;строка введена, причем длина может быть меньше 255
; нужно пройтись по строке
xor ebx,ebx
mov edx,strA; заносим адрес на первый элемент в регистр
doCheckElem:
mov bl, [edx] ;
mov [val],bl
inc edx; увеличиваем edx т.е. адрес на 1, т.о.
;вычисляем адрес следующего элемента или можно сказать, сместили edx на следующий элемент.
;Здесь увеличивам на 1, так размер ячеек байт. Например, если размер ячейки слово, то адрес ствигаем на 2, и т.д.
cmp bl, '0'
jl nextStep
cmp bl, '9'
jg nextStep
; заносим в стек
;Здесь рассматриваются варианты работы команды push;push bx ;(Заносим значение из регистра bx. )
push word [val] ;Здесь пример работы с памятью. При занесении конкретного значения из памятинеобходимо уточнить размер.
;В нашем случае заносим значение размером слово
jmp doCheckElem ;переходим на следующую итерацию цикла, в частности к анализу следующегоэлемента строки
nextStep:
cmp ebx ,0xA ; если вышли из цикла по enter, то строка корректна иначе нет
je stringOk ; если значения совпадают, это значит, что дошли до конца строки,
;а следовательно строка корректна и к этому моменту вся строка лежит в стеке. Переходим наметку stringOk для реализации решения
;Если условие не выполняется, то выводим сообщение о том, что строка не корректна и выходимиз программы с помощью безусловного прыжка на метку exit
mov eax,4
mov ecx, msgNot
mov ebx,1
mov edx,17
int 0x80
jmp exit
stringOk:
xor ebx,ebx ; Обнуляем регистр с помощью побитовой команды
mov edx,strA; заносим адрес на первый элемент в регистр
xor eax,eax
doCheck:
mov bl, [edx] ;
inc edx; увеличиваем edx т.е. адрес на 1, т.о.
;вычисляем адрес следующего элемента или можно сказать, сместили edx на следующий элемент.
;Здесь увеличиваем на 1, так размер ячеек байт. Например, если размер ячейки слово, то адрессдвигаем на 2, и т.д.
; Здесь был вопрос к вам. На что можно заменить два сравнения, находящиеся ниже?
cmp bl, '0'
jl StepPrint
cmp bl, '9'
jg StepPrint
pop ax ; Извлекаем элемент из стека
cmp bl,al; сравниваем элемент из стека с элементом строки. Если не совпадают, то непалиндром.
;Выводим сообщение об этом, путём перехода на метку printNotP,
;иначе проверяем дальше, покане дойдем до конца строки
jne printNotP
StepPrint:
mov eax,4
mov ecx, msgOk
mov ebx,1
mov edx,16
int 0x80
jmp exit
printNotP:
mov eax,4
mov ecx, msgNot
mov ebx,1
mov edx,17
int 0x80
exit:
mov eax, 1
int 0x80